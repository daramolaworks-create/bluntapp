import { supabase } from './supabaseClient';
import { BluntMessage, BluntReply } from '../types';

// Map DB (snake_case) to Client (camelCase)
const mapFromDB = (row: any): BluntMessage => ({
  id: row.id,
  content: row.content,
  isAnonymous: row.is_anonymous,
  allowReply: row.allow_reply,
  createdAt: Number(row.created_at),
  acknowledged: row.acknowledged,
  denied: row.denied,
  recipientName: row.recipient_name,
  recipientNumber: row.recipient_number,
  deliveryMode: row.delivery_mode as any,
  scheduledFor: Number(row.scheduled_for),
  attachment: row.attachment,
  attachmentType: row.attachment_type as any,
  attachmentName: row.attachment_name,
  postToFeed: row.post_to_feed,
  replies: (row.replies || []).map((r: any) => ({
    id: r.id,
    content: r.content,
    createdAt: Number(r.created_at)
  }))
});

// Map Client to DB
const mapToDB = (msg: BluntMessage, userId: string): any => ({
  // id generated by DB or passed if UUID
  user_id: userId,
  content: msg.content,
  is_anonymous: msg.isAnonymous,
  allow_reply: msg.allowReply,
  created_at: msg.createdAt,
  acknowledged: msg.acknowledged,
  denied: msg.denied || false,
  recipient_name: msg.recipientName,
  recipient_number: msg.recipientNumber,
  delivery_mode: msg.deliveryMode,
  scheduled_for: msg.scheduledFor,
  attachment: msg.attachment,
  attachment_type: msg.attachmentType,
  attachment_name: msg.attachmentName,
  post_to_feed: msg.postToFeed || false
});

export const saveBlunt = async (blunt: BluntMessage): Promise<void> => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error("Must be logged in to save");

  const dbPayload = mapToDB(blunt, user.id);
  // Remove ID from payload to let DB generate it, or usage blunt.id if it's a valid UUID
  // blunt.id from types is string, likely UUID from crypto.randomUUID()

  const { error } = await supabase.from('blunts').insert({
    ...dbPayload,
    id: blunt.id
  });

  if (error) throw error;
};

export const getBlunt = async (id: string): Promise<BluntMessage | null> => {
  const { data, error } = await supabase
    .from('blunts')
    .select('*, replies(*)')
    .eq('id', id)
    .single();

  if (error || !data) return null;
  return mapFromDB(data);
};

export const updateBlunt = async (id: string, updates: Partial<BluntMessage>): Promise<void> => {
  // We only support partial updates for specific fields usually, but here's a generic one
  const payload: any = {};
  if (updates.acknowledged !== undefined) payload.acknowledged = updates.acknowledged;
  if (updates.denied !== undefined) payload.denied = updates.denied;

  const { error } = await supabase.from('blunts').update(payload).eq('id', id);
  if (error) throw error;
};

export const addReply = async (bluntId: string, replyContent: string): Promise<BluntMessage | null> => {
  const { error } = await supabase.from('replies').insert({
    blunt_id: bluntId,
    content: replyContent,
    created_at: Date.now()
  });
  if (error) throw error;
  return getBlunt(bluntId);
};

export const acknowledgeBlunt = async (id: string): Promise<void> => {
  await updateBlunt(id, { acknowledged: true });
};

export const denyBlunt = async (id: string): Promise<void> => {
  await updateBlunt(id, { denied: true });
};

export const getStoredBlunts = async (): Promise<BluntMessage[]> => {
  // Supabase RLS ensures we only see our own
  const { data, error } = await supabase
    .from('blunts')
    .select('*, replies(*)')
    .order('created_at', { ascending: false });

  if (error) throw error;
  return (data || []).map(mapFromDB);
};

export const getPublicBlunts = async (): Promise<BluntMessage[]> => {
  const { data, error } = await supabase
    .from('blunts')
    .select('*, replies(*)')
    .eq('post_to_feed', true)
    .order('created_at', { ascending: false });

  if (error) throw error;
  return (data || []).map(mapFromDB);
};
